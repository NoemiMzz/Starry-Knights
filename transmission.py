# -*- coding: utf-8 -*-
"""Transmission.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GJOmSO6qewEed_3x7FwOrhptqoB0FmC9
"""

import os
from google.colab import drive
import numpy as np
import matplotlib.pyplot as plt
from astropy.io import fits
filepath = '/content/drive/MyDrive/'

# prompt: opening a .dat file


def open_dat_file(filepath):
  """Opens a .dat file and returns its contents.

  Args:
      filepath: The path to the .dat file.

  Returns:
      A NumPy array representing the data in the file, or None if an error occurs.
  """
  try:
    # Attempt to open the file as a text file
    data = np.loadtxt(filepath)
    return data

  except ValueError:
    try:
      # If text file opening fails, attempt binary opening
      with open(filepath, 'rb') as f:
          data = f.read()
      return data
    except Exception as e:
        print(f"Error reading file {filepath}: {e}")
        return None

ha = open_dat_file(filepath + 'tobi_ha.dat')
r = open_dat_file(filepath + 'tobi_rsdss.dat')
wave_ha = ha[:,0]
t_ha = ha[:,1]
print(wave_ha)
wave_r = r[:,0]
t_r = r[:,1]
fwhm_ha = (np.nanmax(t_ha) - np.nanmin(t_ha))/2
fwhm_r = (np.nanmax(t_r) - np.nanmin(t_r))/2


idx_ha = np.where(np.abs(t_ha-fwhm_ha)<0.025)

wave_fwhm_ha = wave_ha[idx_ha]
idx_r = np.where(np.abs(t_r-fwhm_r)<0.015)
wave_fwhm_r = wave_r[idx_r]
print(wave_fwhm_ha)
print(wave_fwhm_r)
print(f'larghezza Halfa {wave_fwhm_ha[1]-wave_fwhm_ha[0]}')
print(f'larghezza r: {wave_fwhm_r[1]-wave_fwhm_r[0]}')

#lAMBDA DI PICCO
ha_peak = wave_fwhm_ha[0]+ (wave_fwhm_ha[1]-wave_fwhm_ha[0])/2
r_peak = wave_fwhm_r[0]+ (wave_fwhm_r[1]-wave_fwhm_r[0])/2
print(f'lambda picco ha: {ha_peak}')
print(f'lambda picco r: {r_peak}')
plt.plot(wave_ha, t_ha)
plt.plot(wave_r, t_r)
plt.legend(['Ha', 'r'])
plt.xlabel('Wavelength')
plt.ylabel('Transmission')
plt.axvline(x=ha_peak, color='r', linestyle='--')
plt.axvline(x=r_peak, color='b', linestyle='--')

plt.title('Transmission vs Wavelength')
plt.show()
#il filtro ha centro asimmetrico poiché c'è la quantumeefficiency che smorza

"""
idx_ha = np.argmin(np.abs(t_ha - fwhm_ha))
lambda_ha_fwhm = wave_ha[idx_ha]
# Find the indices where t_r is closest to fwhm_r
idx_r = np.argmin(np.abs(t_r - fwhm_r))
lambda_r_fwhm = wave_r[idx_r]

idx_ha_high = 0
for i in range(len(t_ha)):
    if (i > idx_ha and (np.abs(t_ha[i]-fwhm_ha)<0.001)): #idx_ha primo punto fwhm
        idx_ha_high = i
        lambda_ha_fwhm_high = wave_ha[idx_ha_high]
        break

# Same for r filter
idx_r_low = np.argmin(np.abs(t_r - fwhm_r))
lambda_r_fwhm_low = wave_r[idx_r_low]

idx_r_high = -1
for i in range(len(t_r)-2, -1, -1):
    if (i > idx_r and (np.abs(t_r[i]-fwhm_r)<0.001)):
        idx_r_high = i
        lambda_r_fwhm_high = wave_r[idx_r_high]
        break

# Calculate width
width_ha = np.abs(lambda_ha_fwhm_high  - lambda_ha_fwhm)
width_r = np.abs(lambda_r_fwhm_high - lambda_r_fwhm)

# Now you have the wavelengths associated with the FWHM
print(f"Wavelength at FWHM for Ha: {lambda_ha_fwhm}")
print(f"Wavelength at FWHM for r: {lambda_r_fwhm}")
"""

!pip install photutils

path='/content/drive/MyDrive/'

#collecting all the r unbiased and flattened images
print('...')

from tqdm import tqdm
import numpy as np
import matplotlib.pyplot as plt
from astropy.io import fits
import photutils.aperture as pha
from tqdm import tqdm

#%%
### DATA #######################################################################################################



imR = fits.open(path+'M74_Rband.fits')[0].data
imHa = fits.open(path+'M74_Ha.fits')[0].data

F0 = 3631   #reference flux in Junsky
lambda_r = 6225.0   #central wavelenght of the filter in A
lambda_Ha = 6568.894958496094

largHa = 36.6497802734375   #widht of the filter in A
largR = 1290.0

C_r = 17.125059673553615   #calibration coefficients with errors per band
C_r_err = 0.040374811601885774
C_Ha = 15.539801701451697
C_Ha_err = 0.01580691822059472


#%%
### FUNCTIONS ##################################################################################################

def plotimage(data, minclim, maxclim, title):
    plt.figure()
    plt.imshow(data, cmap='viridis', clim=[minclim, maxclim])
    plt.title(title)
    plt.colorbar()
    plt.show()

def m_to_flux(mag, lambda_c):
    f0 = F0 * 10**(-23)   #reference flux in erg/s/cm2/Hz
    f = f0 * 10**(-mag/2.5)   #flux in erg/s/cm2/Hz
    return f * 3*10**(18) / lambda_c**2

def err_median(x):
    return 0.7413 * (np.percentile(x, 75) - np.percentile(x, 25))

def f_norm(fR):
    return fR * largHa / largR

def net_electrons(fHa, fR, k):
    fR_norm = f_norm(fR)
    return fHa - fR_norm * k


#%%
### CORRECTION FACTOR ESTIMATION ###############################################################################

f = open(path+'stars_coord.txt')   #same stars used in calibration
stars = np.genfromtxt(f, delimiter=';', skip_header=1)

star_flux_net = []
star_flux_Ha = []
kk = np.arange(0.9, 1.3, 0.05)

for n in tqdm(range(len(stars))):
    aperture = pha.CircularAperture((stars[n,0], stars[n,1]), 15)   #define the aperture on the stars

    ff_Ha = pha.aperture_photometry(imHa, aperture)   #collect flux from Ha
    star_flux_Ha.append(ff_Ha['aperture_sum'][0])

    ff_net = []
    for i in range(len(kk)):
        im = net_electrons(imHa, imR, kk[i])   #computing net Ha varying k
        f = pha.aperture_photometry(im, aperture)   #collect flux from netHa
        ff_net.append(f['aperture_sum'][0])
    star_flux_net.append(ff_net)

plt.figure()
[plt.plot(kk, star_flux_net[n] / star_flux_Ha[n], color='royalblue', lw=1) for n in range(len(stars))]
plt.axhline(0, color='black')
plt.axvline(1.04, color='black', ls='dashed')   #chosen k
plt.title('Correction factor estimation')
plt.xlabel('correction factor')
plt.ylabel('$F_{net}$ / $F_{H_{\\alpha}}$ ($e^{-}/s$)')
plt.show()



